#!/usr/bin/env python3

import optparse
import os
import sys
import textwrap
from dataclasses import dataclass
from typing import Iterable


@dataclass
class Config:
    bin_name: str
    uname: str
    target_dir: str
    shared_dir: str
    linux_dir: str
    mac_dir: str
    dry_run: bool


@dataclass
class Link:
    src: str
    dst: str


def mkconfig(opts) -> Config:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    return Config(
        bin_name=sys.argv[0],
        uname=os.uname().sysname,
        target_dir=opts.target_dir,
        shared_dir=os.path.join(script_dir, "configs", "shared"),
        linux_dir=os.path.join(script_dir, "configs", "linux"),
        mac_dir=os.path.join(script_dir, "configs", "mac"),
        dry_run=opts.dry_run,
    )


def print_usage(cfg: Config, exit_code: int):
    msg = f"""\
    Usage: {cfg.bin_name} <COMMAND>

    Target directory defaults to user home unless specified.

    COMMANDS:
        link   [-n] [-t target_dir]  Symlink configuration files into '{cfg.target_dir}'.
        unlink [-n] [-t target_dir]  Remove symlinked configuration files from '{cfg.target_dir}'.
        help                         Print this help.

    Note that setup will only remove files that are linked to this path and
    will only install files that do not already exist, meaning it is always
    safe to run.\
    """
    msg = textwrap.dedent(msg)
    print(msg)
    sys.exit(exit_code)


def link_targets_path(src: str, dst: str) -> Iterable[Link]:
    for dirpath, _, filenames in os.walk(src):
        for fname in filenames:
            srcpath = os.path.join(dirpath, fname)
            relpath = os.path.relpath(srcpath, src)
            dstpath = os.path.join(dst, f".{relpath}")
            yield Link(src=srcpath, dst=dstpath)


def link_targets(cfg: Config) -> Iterable[Link]:
    yield from link_targets_path(cfg.shared_dir, cfg.target_dir)
    if cfg.uname == "Linux":
        yield from link_targets_path(cfg.linux_dir, cfg.target_dir)
    elif cfg.uname == "Darwin":
        yield from link_targets_path(cfg.mac_dir, cfg.target_dir)


def is_linked_here(link: Link) -> bool:
    return os.path.islink(link.dst) and os.path.realpath(link.dst) == os.path.realpath(link.src)


def print_links(links: list[Link]):
    width = max(len(str(x.src)) for x in links)
    print("\n".join(f"    {str(x.src).ljust(width)}  -->  {x.dst}" for x in links))


def print_links_reverse(links: list[Link]):
    width = max(len(str(x.dst)) for x in links)
    print("\n".join(f"    {str(x.dst).ljust(width)}  -->  {x.src}" for x in links))


def install(cfg: Config):
    installed = []
    skipped = []
    already_installed = []
    for link in link_targets(cfg):
        if os.path.lexists(link.dst):
            if is_linked_here(link):
                already_installed.append(link)
            else:
                skipped.append(link)
        else:
            installed.append(link)
    if not cfg.dry_run:
        for link in installed:
            os.makedirs(os.path.dirname(link.dst), exist_ok=True)
            os.symlink(link.src, link.dst)
    if already_installed:
        print("The following were already installed:")
        print_links(already_installed)
    if skipped:
        print("Skipped because another file already exists:")
        print("\n".join(f"    {x.dst}" for x in skipped))
    if installed:
        if cfg.dry_run:
            print("DRY RUN. Would install the following:")
        else:
            print("Installed:")
        print_links(installed)


def remove_empty_dst_dirs(links: list[Link]):
    for link in links:
        dir = os.path.dirname(link.dst)
        while True:
            try:
                os.rmdir(dir)
                dir = os.path.dirname(dir)
            except Exception:
                break


def remove(cfg: Config):
    removed = []
    links_elsewhere = []
    for link in link_targets(cfg):
        if is_linked_here(link):
            removed.append(link)
        elif os.path.exists(link.dst):
            links_elsewhere.append(link)
    if not cfg.dry_run:
        for link in removed:
            os.unlink(link.dst)
        remove_empty_dst_dirs(removed)
    if links_elsewhere:
        print("Kept because not linked here:")
        print("\n".join(f"    {x.dst}" for x in links_elsewhere))
    if removed:
        if cfg.dry_run:
            print("DRY RUN. Would remove the following files:")
        else:
            print("Removed:")
        print_links_reverse(removed)


if __name__ == "__main__":
    # Prefer optparse to argparse for being less opinionated.
    parser = optparse.OptionParser(add_help_option=False)
    parser.add_option("-n", "--dry-run", action="store_true")
    parser.add_option("-t", "--target-dir", type=str, default=os.path.expanduser("~"))
    opts, args = parser.parse_args()
    cfg = mkconfig(opts)
    if len(args) != 1:
        print_usage(cfg, 1)
    cmd = args[0]
    if cmd == "link":
        install(cfg)
    elif cmd == "unlink":
        remove(cfg)
    elif cmd == "help":
        print_usage(cfg, 0)
    else:
        print_usage(cfg, 1)
