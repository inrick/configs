#!/usr/bin/env python3

import optparse
import os
import sys
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


@dataclass
class Config:
    bin_name: str
    uname: str
    target_dir: Path
    shared_dir: Path
    linux_dir: Path
    mac_dir: Path
    dry_run: bool


@dataclass
class Link:
    src: Path
    dst: Path


def mkconfig(opts) -> Config:
    script_dir = Path(__file__).parent
    return Config(
        bin_name=sys.argv[0],
        uname=os.uname().sysname,
        target_dir=opts.target_dir,
        shared_dir=script_dir / "configs" / "shared",
        linux_dir=script_dir / "configs" / "linux",
        mac_dir=script_dir / "configs" / "mac",
        dry_run=opts.dry_run,
    )


def print_usage(cfg: Config, exit_code: int):
    msg = f"""\
    Usage: {cfg.bin_name} <COMMAND>

    Target directory defaults to user home unless specified.

    COMMANDS:
        link   [-n] [-t target_dir]  Symlink configuration files into '{cfg.target_dir}'.
        unlink [-n] [-t target_dir]  Remove symlinked configuration files from '{cfg.target_dir}'.
        help                         Print this help.

    Note that setup will only remove files that are linked to this path and
    will only install files that do not already exist, meaning it is always
    safe to run.\
    """
    msg = textwrap.dedent(msg)
    print(msg)
    sys.exit(exit_code)


def link_targets_path(src: Path, dst: Path) -> Iterable[Link]:
    for dirpath, _, filenames in src.walk():
        for fname in filenames:
            srcpath = dirpath / fname
            relpath = srcpath.relative_to(src)
            dstpath = dst / Path(f".{relpath}")
            yield Link(src=srcpath, dst=dstpath)


def link_targets(cfg: Config) -> Iterable[Link]:
    yield from link_targets_path(cfg.shared_dir, cfg.target_dir)
    if cfg.uname == "Linux":
        yield from link_targets_path(cfg.linux_dir, cfg.target_dir)
    elif cfg.uname == "Darwin":
        yield from link_targets_path(cfg.mac_dir, cfg.target_dir)


def is_linked_here(link: Link) -> bool:
    return link.dst.is_symlink() and link.dst.resolve() == link.src.resolve()


def print_links(links: list[Link]):
    width = max(len(str(x.src)) for x in links)
    print("\n".join(f"    {str(x.src).ljust(width)}  -->  {x.dst}" for x in links))


def print_links_reverse(links: list[Link]):
    width = max(len(str(x.dst)) for x in links)
    print("\n".join(f"    {str(x.dst).ljust(width)}  -->  {x.src}" for x in links))


def install(cfg: Config):
    installed = []
    skipped = []
    already_installed = []
    for link in link_targets(cfg):
        if link.dst.exists(follow_symlinks=False):
            if is_linked_here(link):
                already_installed.append(link)
            else:
                skipped.append(link)
        else:
            installed.append(link)
    if not cfg.dry_run:
        for link in installed:
            link.dst.parent.mkdir(parents=True, exist_ok=True)
            os.symlink(link.src, link.dst)
    if already_installed:
        print("The following were already installed:")
        print_links(already_installed)
    if skipped:
        print("Skipped because another file already exists:")
        print("\n".join(f"    {x.dst}" for x in skipped))
    if installed:
        if cfg.dry_run:
            print("DRY RUN. Would install the following:")
        else:
            print("Installed:")
        print_links(installed)


def remove_empty_dst_dirs(links: list[Link]):
    for link in links:
        dir = link.dst.parent
        while True:
            try:
                dir.rmdir()
                dir = dir.parent
            except Exception:
                break


def remove(cfg: Config):
    removed = []
    links_elsewhere = []
    for link in link_targets(cfg):
        if is_linked_here(link):
            removed.append(link)
        elif link.dst.exists():
            links_elsewhere.append(link)
    if not cfg.dry_run:
        for link in removed:
            os.unlink(link.dst)
        remove_empty_dst_dirs(removed)
    if links_elsewhere:
        print("Kept because not linked here:")
        print("\n".join(f"    {x.dst}" for x in links_elsewhere))
    if removed:
        if cfg.dry_run:
            print("DRY RUN. Would remove the following files:")
        else:
            print("Removed:")
        print_links_reverse(removed)


if __name__ == "__main__":
    # Prefer optparse to argparse for being less opinionated.
    parser = optparse.OptionParser(add_help_option=False)
    parser.add_option("-n", "--dry-run", action="store_true")
    parser.add_option("-t", "--target-dir", type=str, default=Path.home())
    opts, args = parser.parse_args()
    cfg = mkconfig(opts)
    if len(args) != 1:
        print_usage(cfg, 1)
    cmd = args[0]
    if cmd == "link":
        install(cfg)
    elif cmd == "unlink":
        remove(cfg)
    elif cmd == "help":
        print_usage(cfg, 0)
    else:
        print_usage(cfg, 1)
